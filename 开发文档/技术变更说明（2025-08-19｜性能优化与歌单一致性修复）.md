# 2025-08-19｜整体流畅度优化技术变更说明（TechChangeSpec_2025-08-19-Overall-Perf）

## 背景与优化目标

- 设备：安卓手表（低功耗/低算力）。
- 症状：
  - 冷启动后前 30–60 秒滑动卡顿，专辑页快速滑动掉帧明显；设备发热较高。
  - 断网场景仅做本地渲染也会出现较高 CPU 使用。
- 目标：
  - 降低列表滚动阶段的 CPU 峰值与渲染负载，提升专辑/歌曲/歌单列表的流畅度。
  - 控制冷启动后前 1 分钟内的发热；保证 UI 一致，功能零回归。

---

## 问题回溯（基于 Profiler 采样）

- CPU Hotspots（断网滑动）：`glide-source-thread-* / decodeBitmap` 占比高；`Choreographer#doFrame → traversal/draw` 持续出现，Frames 轨道红帧多。
- System Trace：`RV Prefetch / RV Scroll` 与渲染/测量链并发叠加，表明图片解码与列表绑定在竞争主线程与小核算力。
- 补充观察：
  - 默认占位图为矢量 `vector`（200dp），在密集复用中存在额外栅格化成本。
  - `RecyclerView.setDrawingCacheEnabled(true)` 与 `setDrawingCacheQuality(HIGH)` 为过时策略，容易造成额外内存与 CPU 开销。
  - 卡片 `CardView` 使用了 `elevation`，在手表设备上会引入过绘与额外合成成本。
  - 在线场景（后续批次处理）：`OkHttp` 配置 `BODY` 级日志可能放大解析/IO 开销。

> 结论：首要矛盾在于“滚动期的位图解码与绘制压力”。优先通过“图像解码降耗 + 绘制简化”进行批次A优化。

---

## 方案总览（批次A｜已落地）

### 1) 全局 Glide 解码参数降耗（不改行为）
- 新增 `AppGlideModule`：`com.watch.limusic.LiMusicGlideModule`
  - `RequestOptions` 默认：`DecodeFormat.PREFER_RGB_565`、`disallowHardwareConfig()`、`dontAnimate()`。
  - 目的：减少每张位图内存占用与避免硬件位图在手表上导致的额外拷贝/兼容问题。

### 2) 列表封面尺寸下调并统一
- `adapter/AlbumAdapter.java`：网络/本地封面统一 `override(40, 40)`，签名缓存保持；本地文件不写入磁盘缓存。
- `adapter/SongAdapter.java`：歌曲行封面 `override(36, 36)`。
- `adapter/PlaylistAdapter.java`：歌单封面 `override(40, 40)`。
- 均应用与全局一致的 `RequestOptions`（RGB_565、禁动画、禁硬件位图）。

### 3) 占位图由矢量改为轻量 shape
- `res/drawable/default_album_art.xml`：由 200dp 矢量改为 40dp 的简单 `shape`（实色+圆角）。
- 目的：避免频繁矢量栅格化，降低 CPU/GPU 峰值。

### 4) 绘制路径减负
- `MainActivity.setupRecyclerView()`：移除 `recyclerView.setDrawingCacheEnabled(true)` 与 `setDrawingCacheQuality(HIGH)`。
- `res/layout/item_album.xml`、`res/layout/item_playlist.xml`：`app:cardElevation` 由 `1dp` → `0dp`，减少过绘；保留圆角与背景以维持观感。

### 5) 播放器大图封面仍保清晰
- `MainActivity.java` 中播放器区域的专辑大图加载加上统一 `RequestOptions`，但维持 `override(150, 150)`，保证显示品质。

---

## 未包含在本批次、但建议的后续优化（批次B/C 计划）
- 基线配置（Baseline Profile + ProfileInstaller）：缩短冷启动，降低前 30–60 秒 JIT 活跃度与功耗。
- Service 延迟初始化：`PlayerService.initializePlayer()` 延后到首次播放或用户与播放控件交互时。
- 网络日志：将 `OkHttp` 日志级别默认降至 `BASIC`（仅开发调试时临时打开 `BODY`）。
- Room SQL 分页：专辑/列表 DB 访问避免“全表进内存 + subList”，改为 `LIMIT/OFFSET` 范围查询（现已在“所有歌曲”路径完成，专辑路径后续落地）。

---

## 风险与兼容性
- UI/行为不变；仅图片细节与阴影极轻微变化。
- RGB_565 在大多数封面下无感；如个别图片出现带状色阶，可针对该场景局部恢复 `ARGB_8888`（局部 `RequestOptions.format(DecodeFormat.PREFER_ARGB_8888)`）。
- 去除 `DrawingCache` 不影响功能；在现代 `RecyclerView`/`ListAdapter` 下收益明显。

---

## 验证方法（建议在手表设备上复现）

1) 断网，启动后专辑页“快速滑动 20–30 秒”
   - 录制 “Find CPU Hotspots (Callstack Sample)” 与 “Capture System Activities (System Trace)”。
   - 预期：`glide-source-thread-* / decodeBitmap` 占比下降；`Choreographer#doFrame` 红帧明显减少。

2) 断网，“匀速慢滑 20–30 秒”
   - 与快速滑对比：CPU 峰值进一步降低，帧间隔更均匀。

3) 断网，冷启动后“闲置 60 秒”
   - 预期：主线程与渲染线程基本空闲，CPU 使用显著低于优化前。

> 采样关注：Top10 热点、`Frames` 红帧分布、`glide-source-thread-*` 活跃度、`decodeBitmap` 调用链、`RV Prefetch/Scroll` 频率。

---

## 预期收益（以断网场景为主）
- 滑动阶段 CPU 峰值：下降约 25%–45%（设备依赖）。
- 红帧占比：明显减少，手感更“稳”。
- 发热：冷启动后前 1 分钟主体温升幅度降低（与环境温度、壳体散热相关）。

> 在线场景的进一步收益将随批次B（基线/日志级别/延迟初始化）继续释放。

---

## 关键改动清单（按文件）

- `app/src/main/java/com/watch/limusic/LiMusicGlideModule.java`
  - 新增 AppGlideModule，设置全局 `RequestOptions`（RGB_565、禁动画、禁硬件位图）。

- `app/src/main/java/com/watch/limusic/adapter/AlbumAdapter.java`
  - 统一 `RequestOptions`；`override(40, 40)`；本地封面禁用磁盘缓存、网络封面保签名与自动磁盘缓存。

- `app/src/main/java/com/watch/limusic/adapter/SongAdapter.java`
  - 统一 `RequestOptions`；`override(36, 36)`；修正类尾部花括号导致的编译问题。

- `app/src/main/java/com/watch/limusic/adapter/PlaylistAdapter.java`
  - 保持原对外接口不变，封面加载使用统一 `RequestOptions` 与 `override(40, 40)`。

- `app/src/main/java/com/watch/limusic/MainActivity.java`
  - 去除 `RecyclerView` 旧绘图缓存相关调用；播放器大图封面使用统一 `RequestOptions`（仍保持 150x150）。
  - 延迟绑定 `PlayerService`：首次点播放或点歌时再绑定；连接后自动设置待播列表并播放。
  - 未绑定时恢复上次 UI：标题/艺人/封面/模式/进度；并在未绑定时同步显示时间文本。

- `app/src/main/res/drawable/default_album_art.xml`
  - 由矢量图替换为轻量 `shape`（40dp，圆角 4dp）。

- `app/src/main/res/layout/item_album.xml`、`app/src/main/res/layout/item_playlist.xml`
  - `app:cardElevation` 由 `1dp` → `0dp`。

- `app/build.gradle`
  - 增加 `annotationProcessor 'com.github.bumptech.glide:compiler:4.11.0'` 以启用 `AppGlideModule`。

- `app/src/main/java/com/watch/limusic/api/NavidromeApi.java`
  - 默认将 `HttpLoggingInterceptor` 日志级别降为 `BASIC`，降低在线场景 CPU/I/O。

---

## 回滚与开关
- 回滚点：
  - 还原上述文件中的 `RequestOptions` 调整与 `override` 尺寸；恢复 `default_album_art.xml` 为矢量；将 `cardElevation` 恢复；如需，可临时恢复 `DrawingCache`（不推荐）。
  - 若需取消延迟绑定：恢复 `onStart()` 中的 `bindService()` 调用，并移除 `pending*` 逻辑。
- 影响面：仅 UI 渲染与图片解码链；功能零影响。

---

## 维护与后续计划
- 观察期：一周。重点关注“首次启动后 1 分钟内”的帧率、温升与耗电。
- 批次B（建议立刻排期）：
  - 接入 Baseline Profile + ProfileInstaller（首屏关键路径与专辑页滑动路径）。
  - `PlayerService` 延迟初始化；UI 广播在“播放中或拖动时”启用。
  - `OkHttp` 日志级别默认降至 `BASIC`。
- 批次C：专辑页 DB 分页改造，进一步降低大库场景内存占用。

---

## 版本与时间
- 版本：`2.3.0Beta3`（内部）
- 日期：2025-08-19
- 责任人：LiMusic 团队

---

## 问题回溯（新增：歌单拖拽排序稳定性/一致性）

- 现象1：在歌单详情中长按拖动改变歌曲顺序后，列表数秒后或一次刷新后“回到拖动前顺序”（看似回滚）。
- 现象2：松手时偶发“先瞬间回到旧顺序、随后又跳回新顺序”的抖动。
- 复现条件：该歌单此前执行过“删除若干歌曲”或“从服务端增量合并（新增/删除）”。未执行过上述操作的歌单通常不复现。
- 根因分析：
  - 歌单排序以 `playlist_songs.ordinal` 作为真实顺序。删除/合并会导致 `ordinal` 出现“空洞”（例如 0,1,4,5…）。
  - 旧实现将“适配器位置 index（0..n-1）”直接传入 DAO 的 `reorder(from,to)`，而 DAO 的 `from/to` 语义是“旧/新 ordinal”。当 `index ≠ ordinal` 时，就会把错误的条目移动到错误的位置，DB 中实际顺序仍是旧序。
  - UI 层在松手时先做了“视觉快照提交”，暂时显示为新顺序；一旦“DB 重读/服务端轻量校验后的 DB 合并”再次刷新列表，就会显示 DB 的旧顺序，看起来像“回滚”。
  - 松手抖动来自“视觉快照 → 并发刷新覆盖 → 后续再次提交”的竞态过程。

---

## 方案总览（新增：歌单拖拽排序稳定性/一致性）

- 索引→真实序号映射：在仓库层 `reorder(playlistLocalId, fromIndex, toIndex)` 内新增一次轻量查询 `SELECT ordinal FROM playlist_songs WHERE playlistLocalId=? ORDER BY ordinal ASC`，将适配器位置映射为真实 `fromOrdinal/toOrdinal`，再调用 DAO 的 `reorder(playlistLocalId, fromOrdinal, toOrdinal)`。彻底规避 `index ≠ ordinal（空洞）` 造成的错排。
- 抖动抑制：延长“广播刷新抑制窗口”由 700ms → 1500ms，避免松手瞬间的列表重读覆盖视觉快照；且因 DB 顺序即为目标顺序，即使刷新也不会回旧，抖动显著降低。
- 统一入口：删除旧的 `ui/PlaylistDetailActivity`，将 `PlaylistListActivity` 点击行为改为启动 `MainActivity` 并通过 Extra `open_playlist_local_id` 请求打开内嵌详情；Manifest 同步清理，避免双实现的状态与刷新策略不一致。

---

## 关键改动清单（新增）

- `app/src/main/java/com/watch/limusic/database/PlaylistSongDao.java`
  - 新增：`getOrdinalsOrdered(long playlistLocalId)`，按 `ordinal ASC` 返回当前序列，用于 index→ordinal 映射。
- `app/src/main/java/com/watch/limusic/repository/PlaylistRepository.java`
  - 修改：`reorder(long playlistLocalId, int fromIndex, int toIndex)` 先查询 `ordinals` 并映射为 `fromOrdinal/toOrdinal` 后再调用 DAO 的 `reorder(...)`；维持统计与广播逻辑不变。
- `app/src/main/java/com/watch/limusic/MainActivity.java`
  - 修改：拖拽 `clearView` 时将“广播刷新抑制窗口”从 `700ms` 提升至 `1500ms`。
  - 新增：处理 `open_playlist_local_id` 的逻辑（onCreate 与 onNewIntent），统一从 `PlaylistListActivity` 导航到内嵌详情。
- `app/src/main/AndroidManifest.xml`
  - 移除：`com.watch.limusic.ui.PlaylistDetailActivity` 的声明。
- `app/src/main/java/com/watch/limusic/ui/PlaylistListActivity.java`
  - 修改：点击歌单改为启动 `MainActivity` 并携带 `open_playlist_local_id`，由内嵌详情打开。

---

## 验证方法（新增）

1) 使用“曾经删除过/发生过服务端增量合并”的歌单：
   - 拖拽跨多行调整顺序，松手后等待 3–5 秒，不应回滚；下拉刷新同样应保持新顺序。
2) 观察松手瞬间：
   - 不应出现“先回旧再回新”的跳动。极端场景下抖动概率显著下降，不影响最终顺序。
3) 使用“从未删除/合并”的歌单：
   - 作为对照组，拖拽后行为与之前一致。

---

## 性能与影响评估（新增）

- 轻量查询：`SELECT ordinal ORDER BY ordinal ASC` 为 O(n) 一次性查询，仅在“拖拽松手提交”时触发一次；在 50/80/100 首量级下，手表设备开销可忽略不计，相比 UI 绑定与图片解码成本更低。
- 交互体验：延长抑制窗口不改变用户操作，仅减少竞态造成的视觉抖动；不引入额外内存持有。
- 架构一致性：统一到 `MainActivity` 内嵌详情后，减少重复页面引起的逻辑分叉与状态串扰。

---

## 回滚与开关（新增）

- 快速回滚（不建议）：将 `PlaylistRepository.reorder(...)` 恢复为直接以 `from/to` 作为“序号”调用 DAO；或将抑制窗口恢复为 `700ms`。但在存在 `ordinal` 空洞的歌单上将再次出现错排/回滚风险。
- 页面回退：如需恢复独立详情页，需恢复 Manifest 声明与 `PlaylistListActivity` 的旧导航调用；但不建议保留双路径以降低维护复杂度。

---

# （新增）完整问题回溯与解决方案（Perf + Playlist Consistency）

## 问题回溯（完整）
1) 延迟绑定后播放器首屏 UI 空白或进度不显示：未绑定状态未恢复 UI；歌单详情进入未 `ensureProgressBarVisible`/未触发 UI 同步。
2) “首屏记忆”后骨架混叠：恢复目标视图前未统一清理旧 UI/适配器，旧骨架残留。
3) 歌单删除错位/删除后又回来：使用本地推断的 serverIdx 同步删除，在本地/服务端顺序不一致时误删；随后对账把已删项带回。
4) 歌单拖拽“回滚/抖动”：把适配器 index 当作真实 ordinal 写库，在存在 ordinal 空洞（删除/合并）时写错；并发刷新覆盖视觉快照。
5) 统一入口与导航不一致：独立详情页与内嵌详情并行，状态/返回不一致。
6) 在线日志开销：OkHttp BODY 级别在大响应下增加 CPU/I/O。

## 方案总览（含实现要点）
- 未绑定 UI 恢复：从 `player_prefs` 读取 `last_*`，填充标题/艺人/封面/模式；从 DB 估算 `duration`，同步 `seekBar/progressBar` 与 `updateTimeDisplay`；进入歌单详情末尾 `ensureProgressBarVisible()`；若已绑定，调用一次 `updatePlaybackState()`。
- 恢复前统一清理：新增 `resetUiForNewView()`，在 `restoreLastViewOrDefault()` 每个分支先清空适配器并隐藏骨架/空/错态，避免混叠。
- 删除同步精准化：`PlaylistRepository.removeByOrdinals(...)` 后台线程先 `getPlaylist(serverId)` 获取服务器顺序，按 songId → serverIndex 映射 `songIndexToRemove` 调用 `updatePlaylist`；本地删除即时生效，网络失败不回滚本地结果。
- 拖拽稳定：`reorder(playlistLocalId, fromIndex, toIndex)` 先查 `SELECT ordinal ORDER BY ordinal ASC`，将 index 映射为 `fromOrdinal/toOrdinal` 后再调用 DAO 的 `reorder`；广播抑制窗口 700ms→1500ms。
- 统一入口与导航：移除旧 `PlaylistDetailActivity`，统一由 `MainActivity` 通过 `open_playlist_local_id` 打开内嵌详情；返回行为一致。
- 日志级别：OkHttp 日志默认 `BASIC`。

## 关键改动清单（新增）
- `MainActivity.java`：
  - `restoreLastViewOrDefault()` 前置 `resetUiForNewView()`；
  - `openPlaylistDetail(...)` 末尾 `ensureProgressBarVisible()` + 若已绑定则 `updatePlaybackState()`；
  - 保存/恢复 `last_view` 与滚动位置；退出时根据视图类型保存必要 ID。
- `repository/PlaylistRepository.java`：
  - 删除：`getPlaylist` → songId 映射 serverIndex → `updatePlaylist(songIndexToRemove)`；
  - 重排：index→ordinal 映射写库；保持统计/广播一致。
- `database/PlaylistSongDao.java`：补充 `getSongIdsOrdered/ getOrdinalsOrdered`。

## 验证与回归
- 歌单详情：恢复首屏可见进度与时间；删除后刷新或返回重进不回滚。
- 首屏记忆：恢复正确板块且滚动位置一致；无骨架混叠。
- 性能：断网滑动 CPU 峰值下降；红帧减少；冷启动后前 1 分钟发热降低。

## 回滚与开关
- 见上文“回滚与开关”，删除/重排/延迟绑定/首屏记忆均可独立回滚。

## 版本与时间
- 版本：`2.3.0Beta3`
- 日期：2025-08-19
- 责任人：LiMusic 团队
