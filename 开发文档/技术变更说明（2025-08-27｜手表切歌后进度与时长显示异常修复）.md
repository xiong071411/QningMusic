## 2025-08-27｜手表切歌/时长显示异常修复 与 “所有歌曲”滚动稳定性优化（UI兜底 + 服务延迟补发 + 条件绑定放宽 + 稳定ID + 差量刷新 + 滚动期延迟刷新 + 日志降噪）
(TechChangeSpec_2025-08-27-Watch-Progress-Duration-Fix)

### 背景与目标
- 背景：在安卓手表设备上，切歌后偶发出现：
  - 进度条停留在上一首歌的最后位置；
  - 播放器总时长显示为 0:00；
  - 拖动进度条到任意位置都会跳回歌曲开头；
  - 若在该错误状态下退出再进入，“所有歌曲”页面进度条整体不跳动、总时长均为 0；通过手表表盘快捷入口返回应用后又恢复跳动，但拖动仍回到开头。
- 新增问题：手表上滑动“所有歌曲”列表时偶发“闪烁一下并跳到附近位置”，甚至影响点选。
- 目标：
  - 修复低性能设备（手表）切歌/就绪窗口内时长 `UNKNOWN` 导致的 UI 残留与拖动异常；
  - 保持低功耗前提下，提高“就绪后拿到有效时长”的成功率；
  - 提升“所有歌曲”滚动稳定性，杜绝因后台刷新导致的闪烁与跳位；
  - 降低播放前日志噪音。

---

### 问题回溯与根因分析
1) ExoPlayer 就绪时长未知（TIME_UNSET）窗口更长（手表更易放大）
- 现象：`STATE_READY` 当帧 `duration == TIME_UNSET (-9223372036854775807)`。
- 手表端长期开启“强制转码 mp3@320kbps”，在慢核/网络条件下，Ready→可用时长之间窗口相对更长。

2) UI 侧判定过严，导致旧进度残留与 0:00 文本
- 旧逻辑：仅当 `duration > 0` 才设置 `seekBar/progressBar.max` 并推进；否则跳过 → 进度条停在上一首末尾。
- 拖动时以 `playerService.getDuration()` 为准；当其 `UNKNOWN` 时总时长显示为 `0:00`，且 `max==0` 时 `seekTo(progress)` 实际效果等同“回到开头”。

3) 首次进入未及时绑定导致“无心跳纠正”
- UI 心跳（1s）仅在 `isUiVisible=true` 且已绑定时才持续广播；首次进入若未满足“正在播放”的条件绑定，可能仅收到 READY 单帧（且时长未知），后续无心跳纠正。

4) 日志噪音
- 为构建播放列表批量生成 URL 时，输出了大量“强制转码启用/使用流媒体/FLAC回退”日志，影响排查效率。

5) “所有歌曲”滚动闪烁/跳位（新增）
- 现象：滚动列表时偶发闪烁并跳到附近位置，影响点击命中。
- 根因：
  - 后台入库/清库发送 `DB_SONGS_UPDATED` 广播，UI 侧在滚动期间执行 `clearCache()` + `notifyDataSetChanged()` 全量刷新，导致视图重建与锚点丢失；
  - 适配器未启用稳定 ID，`RecyclerView` 难以在全量刷新中保持位置；
  - 刷新前未保存/刷新后未恢复首可见项与偏移。

> 日志证据（手表）：
```text
2025-08-27 11:39:05.894 D PlayerService 播放器就绪
2025-08-27 11:39:05.925 D PlayerService 诊断[STATE_READY]: state=3, isPlaying=true
2025-08-27 11:39:05.925 D PlayerService 进度: pos=0ms, dur=-9223372036854775807ms, bufPos=835ms(0%)
```

---

### 方案总览与实现要点
本次采取“UI 稳态兜底 + 服务端轻量增强 + 绑定策略放宽 + 列表滚动稳定化 + 日志降噪”的组合：

A. UI 侧稳态与兜底（MainActivity）
- 计算 `effectiveDuration = duration>0 ? duration : fallbackDurationMs`。
- 若 `effectiveDuration<=0` 或检测到曲目切换（标题变化）：
  - 立即将 `seekBar/progressBar` 的 `max` 与 `progress` 重置为 0；
  - 时间文本显示为 `00:00 / --:--`（避免显示 0:00 误导）；
  - 待收到任一帧 `effectiveDuration>0` 再设置 `max` 并推进。
- 拖动保护：
  - 当 `seekBar.max<=0`（总时长未就绪）时，暂不提交 `seekTo`，提示“正在获取时长，稍后可拖动”。
  - 拖动过程时间显示：若服务端仍 `UNKNOWN`，从本地 DB（`SongEntity.duration` 秒）兜底估算。

B. 服务侧增强（PlayerService）
- 广播增强：
  - 新增 `songId` 字段；
  - 当 `player.getDuration()` 未就绪时，附带 `fallbackDurationMs=DB.duration*1000` 供 UI 兜底显示。
- READY/切歌后延迟补发一帧：
  - 在 `onPlaybackStateChanged(STATE_READY)` 与 `onMediaItemTransition(...)` 中，除原始补发外，额外 `≈250ms` 再补发一帧，显著提高拿到有效 `duration` 的概率（对功耗影响可忽略不计）。

C. 绑定策略放宽（MainActivity）
- `maybeBindIfPlaying()` 改为“只要存在 `last_song_id` 就绑定”，缩短“无心跳纠正”的空窗，提升首帧恢复的稳定性。

D. 日志降噪（PlayerService）
- 仅对“当前实际要播放的歌曲”输出“强制转码/使用流媒体/FLAC 回退”等详细日志；批量构建播放列表时不再打印，显著降低刷屏。

E. “所有歌曲”滚动稳定性（RecyclerView）（新增）
- 适配器稳定 ID：
  - `AllSongsRangeAdapter` 启用 `setHasStableIds(true)`；为真实项用 `songId.hashCode()` 生成稳定 `itemId`，占位行用位置派生 ID；
  - 显著降低重绑/回收导致的闪烁与跳位。
- 差量刷新替代全清：
  - 新增 `applyTotalCountAndDiff(int newTotal)`，用 `notifyItemRangeInserted/Removed` 替代 `notifyDataSetChanged()`，并清理越界缓存，避免全量闪屏；
  - 仅在 `totalCount` 变化时触发；不再在广播处理中调用 `clearCache()`。
- 滚动期延迟合并刷新：
  - `MainActivity` 监听滚动状态：若处于 `DRAGGING/SETTLING`，标记 `pendingDbUpdate`，待 `IDLE` 再统一处理一次广播；
  - 刷新前记录首可见项与偏移，刷新后用 `scrollToPositionWithOffset` 精确恢复；
  - 始终保留字母索引映射刷新与邻页预取逻辑。

---

### 受影响文件与关键点
- `app/src/main/java/com/watch/limusic/service/PlayerService.java`
  - `sendPlaybackStateBroadcast()`：新增 `songId`、`fallbackDurationMs`（DB 兜底）。
  - `onPlaybackStateChanged(STATE_READY)` / `onMediaItemTransition(...)`：各新增一次 `≈250ms` 延迟补发广播。
  - `getOptimalPlayUrl(...)` + `isCurrentSong(...)`：仅对当前曲目打印转码/来源日志，降低噪音。
- `app/src/main/java/com/watch/limusic/MainActivity.java`
  - 播放状态广播接收：采用 `effectiveDuration`，未知时长即重置 UI 为干净状态（0/--:--），收到有效时长再恢复。
  - 拖动过程/停止：未知总时长时不提交 `seekTo`，并用 DB 时长兜底更新时间文本。
  - `maybeBindIfPlaying()`：放宽为只要存在 `last_song_id` 即绑定。
  - （新增）`DB_SONGS_UPDATED` 处理：滚动期延迟合并刷新；差量更新总数并恢复位置；不再 `clearCache()`。
- `app/src/main/java/com/watch/limusic/adapter/AllSongsRangeAdapter.java`
  - （新增）启用稳定 ID（`setHasStableIds` + `getItemId`）。
  - （新增）`applyTotalCountAndDiff(int)` 与 `getTotalCount()`，实现增删差量更新与对比。

---

### 验证用例与验收标准（手表设备优先）
1) 切歌首帧
- 立即切到下一首：
  - 若首帧仍 `UNKNOWN`，进度条显示为 0，时间显示 `00:00 / --:--`（不再残留上一首末尾，且不显示 0:00 误导）。
  - ≈0.2–0.3s 内收到有效时长后，进度条 `max` 与时间文本自动恢复正常并开始推进。

2) 拖动行为
- 在 `UNKNOWN` 窗口内尝试拖动：不提交 `seekTo`，提示“正在获取时长，稍后可拖动”；窗口过去后可正常拖动。

3) 退出/重进 & 表盘快捷返回
- 在错误状态下退出应用并重进：能稳定恢复进度跳动与正确总时长；
- 从表盘快捷入口返回：同样稳定；不再出现“拖动总回到开头”。

4) 手机端回归
- 手机端切歌、拖动与时间显示行为保持既有正常表现，无回归。

5) “所有歌曲”列表滚动（新增）
- 快速/缓慢滚动 20–30 秒：无闪烁、无位置跳动；
- 滚动中触发后台入库/清库（模拟 `DB_SONGS_UPDATED`）：列表位置不应跳变；
- 点击列表项：命中稳定，无被“闪走”。

通过标准：以上五项全部满足；日志噪音明显下降，仅保留当前曲目的少量关键日志。

---

### 性能与兼容性评估
- 额外广播：READY 与切歌各延迟补发 1 帧，次数极少、数据量小，可忽略对功耗与性能的影响。
- DB 兜底：仅在时长未知的小窗口内按 `songId` 读一次 `SongEntity.duration`，O(1) 轻量查询。
- 绑定放宽：仅在历史记录存在时触发，成本为一次 `bindService`，常驻不增加心跳频度。
- 列表优化：
  - 稳定 ID 与差量刷新均属 `RecyclerView` 推荐做法；
  - 滚动期延迟合并刷新仅改变更新时机，不增加总刷新量；
  - 位置恢复在 UI 线程执行，开销极低。
- 兼容：手机端逻辑不变；仅在“时长未知/曲目切换/列表刷新”分支上新增保护。

---

### 风险与回滚
- 风险：
  - 个别曲目元数据缺失（DB 无 duration）时，兜底总时长仍为 `--:--`，但 READY 后会自动恢复，无功能性影响。
  - 极端场景下，频繁的 `DB_SONGS_UPDATED` 可能在 IDLE 合并时触发一次较大范围差量更新，但不会全量闪屏。
- 回滚策略：
  - 移除 `fallbackDurationMs` 与 UI 兜底分支，恢复旧逻辑；
  - 移除 READY/切歌的延迟补发帧；
  - 将 `maybeBindIfPlaying()` 改回“需 `last_is_playing=true` 才绑定”；
  - 列表稳定性：移除稳定 ID、还原 `notifyDataSetChanged()`（不推荐）；或仅保留稳定 ID 与差量刷新二者之一以二分定位。
  - 日志降噪可单独回退，不影响功能。

---

### 版本信息与变更摘要
- 版本：v2.5（2025-08-27，修复低性能设备切歌/时长显示问题，并优化“所有歌曲”列表滚动稳定性）
- 变更摘要：
  - UI：时长未知窗口的稳态显示（0/--:--），收到有效时长自动恢复；拖动禁用保护 + DB 时长兜底。
  - 服务：READY/切歌延迟补发一帧；广播新增 `songId` 与 `fallbackDurationMs`。
  - 绑定：存在历史曲目即绑定，缩短无心跳窗口。
  - 列表：稳定 ID、差量刷新、滚动期延迟合并刷新与位置恢复，消除闪烁与跳位。
  - 日志：只对当前曲目打印关键来源/转码日志，降噪。

---

### 附：关键日志对照（修复前后）
- 修复前（READY 帧仍 `UNKNOWN`，UI 残留旧进度）：
```text
STATE_READY: dur=-9223372036854775807, UI 不更新 max，进度停在上一首末尾
```
- 修复后：
```text
STATE_READY: dur=UNSET → UI 显示 0 / --:-- → ~250ms 后补发一帧 dur=213000ms → 设置 max 并开始推进
拖动时：若 max==0，提示“正在获取时长，稍后可拖动”；dur 有效后可正常 seek
``` 