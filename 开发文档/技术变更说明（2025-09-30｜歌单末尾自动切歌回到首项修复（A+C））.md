# 技术变更说明（2025-09-30｜歌单末尾自动切歌回到首项修复｜A+C）


## 背景概述
- 用户反馈：在“歌单”的歌曲列表里使用“列表循环”播放，播放完最后一首后自动切歌不会切到歌单第一首；而手动切歌可以切到第一首。在“所有歌曲（全局模式）”列表中无论手动/自动都能回到第一首。
- 目标：在“歌单（非全局）+ 列表循环”场景下，自动切歌从最后一首能正确回到歌单第1首；保持手动切歌、全局模式、随机模式、睡眠定时与转码回退等行为不变。

---

### 方案总览与实现要点
- 采用“A + C”修复组合：
  - A：在曲目过渡回调中检测“窗口回绕”场景，命中后将逻辑索引纠正为歌单首项，并重建窗口对齐索引0。
  - C：对于小歌单（≤120 首）在列表循环模式下执行一次“全量注入”，交由 ExoPlayer 的 `REPEAT_MODE_ALL` 自然回绕至第1首，减少A触发与重建成本。
- 均在 `PlayerService` 内实现，不改变 UI/DB/网络接口；尽量保持低开销，适配手表设备性能。

---

### 问题回溯与根因分析
- 根因：
  - “歌单（非全局）”播放采用“窗口化注入（前5/后15）”。
  - 自动切歌时，服务依赖 ExoPlayer 的 `REPEAT_MODE_ALL`，其仅在“已注入的窗口”中回绕，导致从窗口末尾回到“窗口首项”，而不是“歌单首项索引0”。
  - “所有歌曲（全局模式）”之所以正确，是因为实现了“末尾预追加头块 + 跨入头块后裁剪对齐到0 + 取模映射”的全局滑动窗口逻辑。
- 复现场景：
  - 当处于“歌单最后一首”且窗口覆盖到列表尾部时，自动切歌将回到窗口首项（例如索引39），而非歌单第1首（索引0）。

---

### 受影响文件与关键点
- `app/src/main/java/com/watch/limusic/service/PlayerService.java`
  - `onMediaItemTransition(...)`：新增“窗口回绕纠正”逻辑（A）。
  - `applyPlaybackMode()`：在 `PLAYBACK_MODE_REPEAT_ALL` 下对小歌单执行“全量注入”（C）。
  - 统一监听器与内部使用 `NavidromeApi` 的方式为服务字段 `navidromeApi`，避免 `getInstance(this)` 在监听器上下文中的潜在不当引用。

---

### 关键代码与日志对照（节选）
- 复现日志：末尾起播时仅注入了窗口 `[39,45)`，自动切歌后跳到窗口首项 39：
```75:76:log.txt
2025-09-30 23:41:49.506 28512-28512 PlayerService           com.watch.limusic                    D  切换到歌曲: 悠哉日常~悠哉~悠哉, 索引: 39
2025-09-30 23:41:49.507 28512-28512 PlayerService           com.watch.limusic                    D  原因: 自动切换到下一首
```
- A 修复：在曲目过渡时检测“歌单末尾→窗口首项”并对齐到歌单首项，重建窗口 `[0, NEXT_CHUNK+1)`：
```420:467:app/src/main/java/com/watch/limusic/service/PlayerService.java
@Override
public void onMediaItemTransition(MediaItem mediaItem, int reason) {
    if (mediaItem != null) {
        int newIndex = player.getCurrentMediaItemIndex();
        // A修复：非全局+列表循环+自动切歌且此前位于歌单末尾，若回绕到窗口首项且窗口覆盖到歌单尾，则纠正为歌单首项
        try {
            if (!useGlobalAllSongsMode && playbackMode == PLAYBACK_MODE_REPEAT_ALL && reason == Player.MEDIA_ITEM_TRANSITION_REASON_AUTO && sleepType != SleepType.AFTER_CURRENT) {
                int prevIdx = currentIndex;
                int listSize = (playlist != null ? playlist.size() : 0);
                int mediaCount = Math.max(0, player.getMediaItemCount());
                int windowStartLocal = mediaBasePlaylistIndex;
                int windowEndLocal = windowStartLocal + mediaCount;
                boolean atListEnd = (prevIdx >= 0 && listSize > 0 && prevIdx == listSize - 1);
                boolean windowCoversListEnd = (listSize > 0 && windowEndLocal >= listSize);
                boolean wrappedWindowHead = (newIndex == 0);
                if (atListEnd && windowCoversListEnd && wrappedWindowHead && windowStartLocal != 0) {
                    final int NEXT_CHUNK = 15;
                    int wStart = 0;
                    int wEnd = Math.min(listSize, NEXT_CHUNK + 1);
                    java.util.List<MediaItem> items = new java.util.ArrayList<>();
                    for (int i = wStart; i < wEnd; i++) {
                        Song s = playlist.get(i);
                        String url = navidromeApi.getStreamUrl(s.getId());
                        items.add(buildStreamingMediaItem(s.getId(), getOptimalPlayUrl(s, url)));
                    }
                    currentIndex = 0;
                    try { currentSong = playlist.get(0); } catch (Throwable ignore) {}
                    mediaBasePlaylistIndex = 0;
                    handler.post(new Runnable() { @Override public void run() {
                        try {
                            player.stop();
                            player.clearMediaItems();
                            player.setMediaItems(items, 0, 0);
                            player.prepare();
                            applyPlaybackMode();
                            play();
                        } catch (Throwable ignore) {}
                    }});
                    Log.d(TAG, "检测到窗口首回绕，已纠正为歌单首项并重建窗口[0," + wEnd + ")");
                    return;
                }
            }
        } catch (Throwable ignore) {}
        // ... existing code ...
    }
}
```
- C 优化：`REPEAT_ALL` 下对小歌单（≤120）全量注入：
```1363:1392:app/src/main/java/com/watch/limusic/service/PlayerService.java
case PLAYBACK_MODE_REPEAT_ALL:
    player.setRepeatMode(Player.REPEAT_MODE_ALL);
    player.setShuffleModeEnabled(false);
    Log.d(TAG, "设置播放模式: 列表循环");
    // C修复：非全局 + 列表循环下，对小歌单全量注入，避免自动回绕仅在窗口内循环
    if (!useGlobalAllSongsMode) {
        int listSize = (playlist != null ? playlist.size() : 0);
        int mediaCount = player != null ? player.getMediaItemCount() : 0;
        if (listSize > 0 && listSize <= FULL_INJECT_THRESHOLD && mediaCount != listSize) {
            int keep = 0;
            long curPos = 0L;
            try { curPos = Math.max(0, player.getCurrentPosition()); } catch (Throwable ignore) {}
            if (currentSong != null) {
                for (int i = 0; i < listSize; i++) { if (currentSong.getId().equals(playlist.get(i).getId())) { keep = i; break; } }
            } else {
                keep = Math.min(Math.max(0, currentIndex), Math.max(0, listSize - 1));
            }
            java.util.List<MediaItem> items = new java.util.ArrayList<>(listSize);
            for (int i = 0; i < listSize; i++) {
                Song s = playlist.get(i);
                String url = navidromeApi.getStreamUrl(s.getId());
                items.add(buildStreamingMediaItem(s.getId(), getOptimalPlayUrl(s, url)));
            }
            mediaBasePlaylistIndex = 0;
            try {
                player.setMediaItems(items, Math.max(0, keep), Math.max(0, curPos));
                player.prepare();
            } catch (Throwable ignore) {}
        }
    }
    break;
```

---

### 验证用例与回归范围
- 核心验证：
  - 在“歌单（非全局）+ 列表循环”中，播放最后一首后自动切歌，是否正确回到歌单第1首。
- 兼容性验证：
  - 手动“上一首/下一首”的行为不变。
  - “所有歌曲（全局模式）”保持既有滑动窗口与回绕行为。
  - 随机模式：全局随机（自定义）与本地随机（小歌单全量注入）均不受影响。
  - 睡眠定时（AFTER_CURRENT）、解码异常回退（转码MP3）流程不受影响。
- 回归范围：`PlayerService` 播放列表注入、曲目过渡、播放模式应用。

---

### 性能与功耗评估（手表优先）
- A 修复仅在“末尾回绕”命中一次重建小窗口，对CPU/内存影响极小。
- C 优化仅在小歌单（≤120）触发一次全量注入，常态开销可忽略；大歌单不触发，保证内存友好。
- 未引入额外高频任务，不增加广播与主线程负担。

---

### 风险与回滚方案
- 风险：极端边界（极小列表、索引计算异常）下可能出现一次性窗口重建失败（已有 try/catch 兜底）。
- 回滚：
  - 移除 `onMediaItemTransition` 中“窗口回绕纠正”分支与 `applyPlaybackMode` 中“小歌单全量注入”逻辑，即可回退到修复前行为。

---

### 与历史版本/问题的关系
- 延续并兼容此前“全局所有歌曲滑动窗口播放与元数据一致性修复（2025-08-27）”的设计；本次仅在“非全局歌单”补齐自动回绕缺失。

---

### 受影响文件
- `app/src/main/java/com/watch/limusic/service/PlayerService.java`

---

### 版本与构建信息
- 目标版本：4.0Beta4 主干
- 平台：Android（minSdk 27，targetSdk 33），JDK 17
- 播放：ExoPlayer 2.18.7

---

### 后续工作
- 观察用户在大歌单场景下的实际体验数据；如需进一步一致化，可评估为“非全局歌单”引入“头块预追加 + 跨入后裁剪”的通用机制（与全局一致）。 