## 2025-08-25｜服务器切换与歌单修复

### 背景与目标
- 背景：用户反馈“首次保存服务器后，后续更改无效，仍使用第一次服务器请求”；切换服务器后“所有歌曲”残留旧数据、播放报错；“歌单”在切换服务器后列表为空、切回原服务器也无法恢复。
- 目标：
  - 服务器设置“保存后立即生效”，无需重启或重建服务；正在播放/下载应立即中断并切向新服务器。
  - 设置页“测试连接”使用当前输入值，不依赖是否保存。
  - 切换服务器时清理旧服务器的残留数据，避免“所有歌曲”混入旧数据、播放报错。
  - 歌单页在切换服务器后可正确显示，当切回原服务器时可恢复；兼容不同 Navidrome 版本的返回结构（单对象/数组）。

---

### 问题回溯与根因分析
1) 服务器切换后仍使用首次服务器
- 现象：保存新服务器后仍访问第一次配置的服务器。
- 根因：`NavidromeApi` 为单例，凭据仅在构造时 `loadCredentials()` 一次；`PlayerService` 启动时持有该单例引用，后续不刷新。

2) “所有歌曲”混入旧服务器数据/播放报错
- 现象：切换服务器后“所有歌曲”出现重复（两套服务器相同歌曲），旧服务器项播放报 `UnrecognizedInputFormatException`。
- 根因：仅清了 `songs` 的一部分或未清理成功；播放路径用“新服务器 baseUrl + 旧 songId”，服务端返回非音频，导致 ExoPlayer 无法识别；升级路径中清库触发外键约束失败（`playlist_songs -> songs` 外键 `NO_ACTION`），`DELETE FROM songs` 被拒绝，残留旧数据。

3) 设置页“测试连接”仍走旧配置
- 现象：测试连接在单例已初始化后仍使用旧服务器。
- 根因：测试逻辑通过单例 `NavidromeApi.ping()`，而非使用当前输入值构造一次性请求。

4) 切换服务器后“歌单”列表空白，切回也不恢复
- 现象：切换后“歌单”页无数据；创建新歌单能同步，但切回原服务器后仍不可见。
- 根因：
  - 部分 Navidrome 返回 `playlists.playlist` / `playlist.entry` 为“单对象”而非数组，严格按数组解析时被丢弃。
  - 头部对账逻辑曾对本地歌单做“软删除”标记，但当服务端再次出现该歌单时没有取消软删除；UI 展示阶段还会因为 `isDeleted` 直接跳过，造成“远端存在但本地不可见”。
  - 服务器切换未清空 `playlists` 表，叠加软删除导致恢复异常。

5) 兼容性/构建问题（开发中遇到）
- `JsonParser.parseString` 在老版 Gson 不可用。
- 一度移除/覆盖了 `getRequestBuilder(String)` 导致编译失败。
- 广播常量未导出/未统一引用，导致引用找不到符号。

---

### 方案总览与实现要点
A. 服务器配置“保存后立即生效”
- `NavidromeApi`
  - 每次构建请求 `getBaseUrlBuilder()` 之前调用 `loadCredentials()`，确保请求时读取最新配置（代价极小，手表可接受）。
  - 新增 `public synchronized void reloadCredentials()`，供收到广播时显式刷新。
  - 新增公共常量 `ACTION_NAVIDROME_CONFIG_UPDATED` 作为配置更新广播动作。
- `NavidromeSettingsActivity`
  - “测试连接”改为调用静态 `NavidromeApi.ping(serverUrl, port, username, password)`，不用单例。
  - “保存设置”后发送 `ACTION_NAVIDROME_CONFIG_UPDATED` 并 toast “已切换至新服务器”。
- `PlayerService`
  - 注册接收 `ACTION_NAVIDROME_CONFIG_UPDATED`：`reloadCredentials()`；`player.stop()` + `clearMediaItems()`；清空播放队列与回退状态，广播一次播放状态更新。
- `DownloadManager`
  - 注册接收 `ACTION_NAVIDROME_CONFIG_UPDATED`：执行 `cancelAll()` 取消进行中的下载。

B. 切换服务器的数据清理（升级用户稳健）
- `MusicRepository.purgeAllOnServerSwitch()`
  - 顺序：先 `playlist_songs.deleteAll()` → 再 `songs.deleteAllSongs()` → 再 `playlists.deleteAll()`（头部）
  - 解决升级过程中 `FOREIGN KEY constraint failed (787)` 与头部残留引起的显示异常。
- `MainActivity` 自检兜底（防广播丢失）：
  - 新增“服务器签名”：`server_url|server_port|username`。
  - `onStart()` 比较当前签名与 `ui_prefs.last_server_signature`，如变化则调用 `purgeAllOnServerSwitch()` 并跳转刷新“所有歌曲”，随后写入新签名。
  - 广播接收器在处理完也会写入签名，避免重复清库。

C. “歌单”稳定性与兼容性
- 解析兼容：
  - `NavidromeApi.getPlaylists()`：若 `playlists.playlist` 为对象，则包装为单元素数组再解析。
  - `NavidromeApi.getPlaylist()`：若 `playlist.entry` 为对象，则包装为单元素数组再解析。
  - 采用兼容旧 Gson 的 `JsonParser`：`new JsonParser().parse(json)` 封装为 `parseJsonObjectCompat`。
- 软删除恢复：
  - `PlaylistRepository.syncPlaylistsHeader()`：当远端存在该歌单时，强制 `exist.setDeleted(false)` 并更新。
  - `MainActivity.loadPlaylists()`：UI 展示不再因本地 `isDeleted` 直接跳过，优先以远端可见为准。
- 持久化时序：
  - 当网络拿到远端列表后，UI 先展示，同时立即调用 `playlistRepository.syncPlaylistsHeader()` 回写本地，随后再做一次对账与孤儿清理，确保切回/重启有 DB 回退。

D. 其他
- `PlaylistSongDao` 新增 `deleteAll()`；`PlaylistDao` 新增 `deleteAll()`。
- 调整所有引用为 `com.watch.limusic.api.NavidromeApi.ACTION_NAVIDROME_CONFIG_UPDATED`。
- 恢复 `NavidromeApi.getRequestBuilder(String)`，修复编译问题。

---

### 受影响文件与关键点
- `app/src/main/java/com/watch/limusic/api/NavidromeApi.java`
  - 新增 `ACTION_NAVIDROME_CONFIG_UPDATED`、`reloadCredentials()`、静态 `ping(...)`、兼容 JSON 解析、请求前 `loadCredentials()`。
- `app/src/main/java/com/watch/limusic/NavidromeSettingsActivity.java`
  - 测试连接使用静态 `ping(...)`；保存后广播 + toast。
- `app/src/main/java/com/watch/limusic/service/PlayerService.java`
  - 注册配置更新广播：刷新凭据、停播清队列、同步 UI。
- `app/src/main/java/com/watch/limusic/download/DownloadManager.java`
  - 注册配置更新广播：`cancelAll()` 中断下载。
- `app/src/main/java/com/watch/limusic/database/PlaylistSongDao.java`
  - 新增 `deleteAll()`。
- `app/src/main/java/com/watch/limusic/database/PlaylistDao.java`
  - 新增 `deleteAll()`。
- `app/src/main/java/com/watch/limusic/database/MusicRepository.java`
  - `purgeAllOnServerSwitch()`：清空顺序与范围（明细/歌曲/头部）。
- `app/src/main/java/com/watch/limusic/repository/PlaylistRepository.java`
  - `syncPlaylistsHeader()`：远端存在则取消本地软删除并对齐字段。
- `app/src/main/java/com/watch/limusic/MainActivity.java`
  - `loadPlaylists()`：展示逻辑不再因本地 `isDeleted` 跳过；网络展示后立即 `syncPlaylistsHeader()`；
  - 广播接收器 + `onStart()` 服务器签名自检清库与刷新“所有歌曲”。

---

### 验证用例与验收标准
A. 服务器切换即时生效
- 保存新服务器后，不重启应用或服务：
  - 后续请求（专辑、歌单、封面、流链接）均指向新服务器。
  - 正在播放立即停止并清队列；正在下载立即中断。
  - 设置页“测试连接”仅用当前输入值测试，保存与否无关。

B. “所有歌曲”一致性
- 切换服务器后列表不出现旧服务器残留；不出现重复项。
- 切回原服务器后，列表为原服务器的数据。
- 播放不再报 `UnrecognizedInputFormatException`（不再出现“新 baseUrl + 旧 songId”组合）。

C. “歌单”一致性
- 切换服务器后，歌单列表可见；切回原服务器后能恢复。
- 创建/删除/公开私有变更能在当前服务器快速同步并持久化。
- 兼容 `playlists.playlist` / `playlist.entry` 单对象返回。

---

### 性能与兼容性评估
- 性能：
  - 每次请求前 `loadCredentials()` 为轻量 SharedPreferences 读；对手表端影响可忽略。
  - 服务器切换时清空三表为一次性操作；正常使用中无额外开销。
- 兼容：
  - Gson 解析采用旧版兼容方式；适应不同 Navidrome 版本结构差异。
  - 广播+签名自检双保险，确保不同生命周期下都能正确切换。

---

### 回滚策略
- 若发现切换服务器后“歌单”仍异常：
  - 可暂时移除 `playlists.deleteAll()`，仅保持 `playlist_songs` 与 `songs` 清空；
  - 或回退 `PlaylistRepository.syncPlaylistsHeader()` 中的“取消软删除”变更，结合日志定位服务端结构差异。
- 若性能受限：
  - 可改为仅在广播到达时 `reloadCredentials()` 而非每请求前 `loadCredentials()`；需加强时序与空窗处理。

---

### 版本信息与变更摘要
- 分支/版本：v2.3 系列后续增量（2025-08-25）
- 变更摘要：
  - 服务器切换即时生效（广播 + 每请求刷新凭据 + 静态测试）。
  - 切换服务器清空 `playlist_songs`、`songs`、`playlists`，杜绝残留；“所有歌曲”无重复、播放无报错。
  - 歌单解析兼容单对象；远端存在即取消本地软删除；展示与持久化时序优化，切回可恢复。

---

### 附：日志证据（节选）
```text
OkHttp 200: GET /rest/getRandomSongs ...
ExoPlayer E  Playback error: UnrecognizedInputFormatException (切换前残留旧 songId 导致)
SQLiteConstraintException: FOREIGN KEY constraint failed (787) at SongDao_Impl.deleteAllSongs (切换时先清明细再清歌曲解决)
OkHttp 200: GET /rest/getPlaylists ... (切换后歌单拉取成功)
``` 