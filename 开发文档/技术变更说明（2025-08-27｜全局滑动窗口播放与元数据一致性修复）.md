# 2025-08-27—2025-08-28｜全局滑动窗口播放与元数据一致性修复 + 全局随机播放（实现） + 列表刷新抑制 + 进度广播三档（TechChangeSpec_2025-08-27_28-GlobalSlidingWindow-and-Shuffle）

## 背景与目标

- 背景（手表设备）：
  - “所有歌曲”顺播到列表末尾时，会跳回窗口头部的非首曲；
  - 某些区间（46–60段）正在播放的音频与底部播放器元数据显示不一致；
  - 末曲拖到尾部触发自动切歌后，底部仍显示末曲信息但实际已播放另一首；
  - 冷启动后存在大量系统/编解码日志打印；
  - 有时自动切歌时出现 ExoPlayer AudioSink 不连续警告；
  - 版本记忆的“上次离开时的曲目”偶发不正确。
- 目标：
  - 在不一次性构造“大列表”的前提下，支持任意规模库的顺播/循环，并在末尾衔接到真正的第一首；
  - 保证任何切歌路径下，UI 元数据与实际音频严格一致；
  - 修复“上次播放位置/曲目”的记忆与恢复；
  - 统一“歌单/专辑/所有歌曲”的滚动期刷新抑制，减少闪烁与跳位；
  - 提供进度广播三档可选（0.5s/1.5s/2.5s）。

---

## 问题回溯（现象与根因）

1) “所有歌曲”末尾衔接错误
- 现象：末尾曲目播放完未回到真正第 1 首，而是回到之前窗口的头部曲目（如从第 184 首跳到第 134 首）。
- 根因：旧实现使用“±N 窗口”构造播放列表，ExoPlayer 在窗口尾部循环回窗口头部，而非全局首曲。

2) 元数据显示与音频不一致（46–60 段、末曲自动切歌）
- 现象：音频已切换到新曲，但底部显示仍为上一曲；或显示为末曲但实际已在播放另一首。
- 根因：
  - 媒体项索引（player.mediaIndex）→ 全局索引与窗口相对索引的映射未覆盖“末尾追加头块 / 窗口回收重建”两种边界；
  - 回收窗口媒体项后，内存中的 `playlist` 未同步裁剪，导致 UI 从过期列表取元数据。

3) 版本记忆的最后曲目错误
- 现象：有时恢复到第 152 首或其他非预期曲目。
- 根因：
  - 在“全局所有歌曲”场景下仍使用普通列表的持久化字段（IDs + index），与滑动窗口策略不匹配；
  - 恢复时按列表路径尝试重建，索引漂移。

4) 自动切歌偶发 `AudioSink$UnexpectedDiscontinuityException`
- 现象：音频时间戳不连续警告，但不影响播放。
- 根因：换曲/末尾切换时某些设备音频轨时间戳存在跳变；属 ExoPlayer 与设备/驱动差异，功能上可忽略。

5) 冷启动日志警告较多（仅分析）
- MediaButtonReceiver 未找到唯一接收者、XING data size mismatch、编解码器能力提示、RecyclerView 无适配器、Skipped frames 等；多为可忽略的环境/时序打印，不影响主要功能。

---

## 方案总览（不改变用户操作逻辑）

A) 全局“所有歌曲”滑动窗口播放
- 引入全局状态（PlayerService）：
  - `useGlobalAllSongsMode`：是否启用全局模式；
  - `globalTotalCount`：真实总数；
  - `windowStart/windowEnd`：当前注入到 ExoPlayer 的全局索引区间 [start, end)；
  - `mediaBasePlaylistIndex`：保持“player.mediaIndex=0 对应的全局 index=windowStart”；
  - 参数：`WINDOW_CHUNK=60`、`WINDOW_GUARD=4`、`WINDOW_MAX=240`。
- 初始化：
  - 点击第 k 首时，以 k 为中心构建首块窗口，`mediaBasePlaylistIndex=windowStart`，立即起播。
- 按需扩边（主线程 addMediaItems）：
  - 接近尾侧（mediaIndex ≥ count-1-guard）→ 追加 [windowEnd, windowEnd+CHUNK)；若已到全局末尾则预追加头块 [0, CHUNK) 以实现循环；
  - 接近首侧（mediaIndex ≤ guard）→ 在头部插入 [windowStart-CHUNK, windowStart)，并 `seekTo(p+add, position)` 保持当前曲目不跳。
- 回收：
  - 窗口超过 `WINDOW_MAX` 时，移除远端前段，`windowStart+=removeFront`，同步更新 `mediaBasePlaylistIndex` 与 `playlist.subList(0, removeFront).clear()`。

B) 元数据一致性保障（映射与兜底）
- 切歌回调 `onMediaItemTransition`：
  - 先将 `player.mediaIndex` 映射为全局索引（全局模式下对 total 取模包络）；
  - 计算相对窗口索引：
    - 若 `mappedIndex∈[windowStart,windowEnd)` → `rel = mappedIndex - windowStart`；
    - 若处于“末尾追加的头块” → `rel = baseLen + mappedIndex`（`baseLen=windowEnd-windowStart`）；
    - 否则兜底 `musicRepository.getSongsRange(1, mappedIndex)` 拉取该曲；
  - 用得到的 `rel/兜底曲目` 更新 `currentSong`，确保 UI 元数据与音频一致。

C) 播放状态持久化与恢复（全局模式）
- 写入：
  - 新增键：`last_global_all_songs=true/false`、`last_global_index=currentIndex`；
  - 全局模式下不再保存“IDs + index”的普通列表持久化字段。
- 恢复：
  - 优先检测 `last_global_all_songs`：若为 true，通过 `playAllSongsFromGlobalRestore(globalIndex, positionMs)` 初始化窗口并定位到上次位置（暂停态，不自动播放），随后 UI 可点击播放续播；
  - 普通列表模式维持原逻辑不变。

D) 滚动期刷新抑制（歌单/歌单详情）
- 歌单头/明细：收到 `PLAYLISTS_UPDATED / PLAYLIST_CHANGED` 时，若在 `DRAGGING/SETTLING` 滚动中则延迟到 IDLE 后 150–180ms 合并刷新，避免频繁 `notify*` 抖动；
- 打开歌单详情时：
  - 先 `resetUiForNewView()` 清理旧视图；
  - 显示骨架；
  - 本地先显，使用 `tokenPid` 校验仅更新当前请求歌单，避免异步回写错闪；
  - 服务端刷新仅在确有变更时再应用。

E) 进度广播频率三档（不依赖低耗开关）
- 设置页点击轮换：`progress_broadcast_mode ∈ {0,1,2}` → 0.5s / 1.5s / 2.5s；
- 服务心跳读取该值作为 UI 广播频率；默认 0.5s。

F) 始终读写缓存
- 撤销“仅读缓存”试验：统一使用读写缓存，避免频繁走网络带来的更高功耗与发热。

---

## 2025-08-28 新增（全局随机播放 + 末尾→首曲对齐裁剪 + 60→61 边界修复）

- 全局随机播放（已实现）：
  - 模式：`PLAYBACK_MODE_SHUFFLE`
    - 全局“所有歌曲”：禁用 ExoPlayer 内建 shuffle，采用自定义“全局随机索引跳转”。
      - 下一首：随机挑选不同于当前的全局索引；若不在窗口内则以目标为中心重建窗口后跳转；记录随机历史。
      - 上一首：从随机历史回退；无历史则再次随机挑选不同于当前的索引。
    - 普通播放列表：沿用 ExoPlayer 内建 shuffle，切换模式时保持当前曲目与播放位置。
  - 新增字段：`shuffleRandom`、`shuffleHistory(64)`；新增方法：`pickRandomGlobalIndexAvoidingCurrent()`、`jumpToGlobalIndex(int,long,boolean)`。
  - 验收：全局模式反复“下一首/上一首”均为真正全局随机，不受窗口边界限制。

- 末尾→首曲对齐裁剪：
  - 当已预追加“头块”且当前进入头块区域时，主动裁剪队列前部基础窗口，并将 `windowStart` 对齐为 0，`windowEnd=appendedHead`，同步裁剪内存 `playlist`；保证循环回到真正第 1 首。

- 60→61 边界修复：
  - 先前因基于窗口上限计算 `currentIndex` 导致的错跳，已改为在全局模式下优先通过队列 `seekToNextMediaItem()` 前进；随机模式则走“全局随机跳转”。

- 日志与诊断：
  - 全局模式下诊断日志的总数分母统一使用 `globalTotalCount`；便于对照全局索引。

- 编译修复：
  - 补充 `PlayerService` 中缺失的 `shuffleRandom` 与 `shuffleHistory` 字段声明，解决符号未找到错误。

- 风险与回退：
  - 若个别设备在进入头块并裁剪时出现竞态，可临时关闭“头块预追加”策略，改为到达末尾瞬间再跳到首块（体验轻微可感，安全优先）。

- 验证要点：
  - 全局模式：从第 60 首“下一首”至 61 不再错跳；末尾自动切歌或手动“下一首”均衔接真正第 1 首。
  - 随机模式：全局下随机跳转不依赖窗口，上一首可用历史回退；普通列表随机保持原体验。

### 2025-08-28 附加新增（非全局随机生效｜歌单详情系统返回修复）

- 非全局随机（专辑/歌单详情）生效（方案A）：
  - setPlaylist 不再强制关闭随机或覆盖播放模式，准备媒体项后统一调用 applyPlaybackMode()，尊重当前模式；
  - 非全局 + 随机模式下，next()/previous() 使用 ExoPlayer 队列跳转（seekToNextMediaItem/seekToPreviousMediaItem）；
  - 说明：当前随机范围受窗口化注入限制（约“前5后15”），属最小改动策略，如需扩大覆盖可按后续方案B；
- “歌单详情”系统返回修复：
  - 现象：在“歌单详情”使用系统返回直接退出应用，无法回到歌单列表；
  - 方案：在 onBackPressed() 中优先处理 selectionMode 退出；当 currentView=="playlist_detail" 时调用 navigateBackToPlaylists() 返回歌单列表；
  - 验证：在“歌单详情”按系统返回应回到歌单列表；如处于多选状态则先退出多选。

---

## 关键改动清单（按文件）

- `app/src/main/java/com/watch/limusic/service/PlayerService.java`
  - 新增全局模式：`useGlobalAllSongsMode/globalTotalCount/windowStart/windowEnd/WINDOW_*`；
  - 新增：`playAllSongsFromGlobal(int)`（初始化窗口并起播）、`playAllSongsFromGlobalRestore(int,long)`（恢复不自动播放）；
  - 切歌映射：在 `onMediaItemTransition` 中，将 `player.mediaIndex` → 全局索引 → 窗口相对索引，覆盖“末尾头块/窗口回收”边界；
  - 回收：移除前段媒体项时同步裁剪 `playlist.subList(0, n).clear()`；
  - 持久化：新增 `last_global_all_songs/last_global_index` 并优先恢复全局模式；
  - 进度广播：读取 `progress_broadcast_mode` 设置 0.5/1.5/2.5s 三档。

- `app/src/main/java/com/watch/limusic/MainActivity.java`
  - `onSongClick(...)`：在“所有歌曲”适配器场景下改为调用 `playerService.playAllSongsFromGlobal(position)`；
  - 歌单详情：进入前 `resetUiForNewView()` + 骨架 + `tokenPid` 校验，仅更新当前歌单；
  - 歌单广播：滚动期延迟合并刷新（150–180ms）。

- `app/src/main/java/com/watch/limusic/adapter/AllSongsRangeAdapter.java`
  - O(1) 缓存判断：改用 `CacheManager.isCachedByKey("stream_mp3_"+id|"stream_raw_"+id)`；
  - 下载状态：后台预扫描一次 + 内存集合维护；
  - 单线程后台执行器，降低 UI 干扰。

- `app/src/main/java/com/watch/limusic/cache/SmartDataSourceFactory.java`
  - 恢复为统一读写缓存（移除只读分支）。

- `app/src/main/java/com/watch/limusic/SettingsActivity.java` / `res/layout/activity_settings_list.xml`
  - 新增“播放进度广播频率”卡片（三档轮换，独立于低耗模式）；
  - 保留“低耗模式”卡片说明（当前未改变缓存行为）。

---

## 遇到的具体问题与解决（按序）

1) 窗口尾部循环回窗口头（导致跳到中间曲目）
- 解决：改为“可滑动的全局窗口”，接近尾部时追加下一块（或追加头块实现循环），保证末尾衔接到真正首曲。

2) 元数据显示与音频不一致（尤其 46–60 段、末曲自动切歌后）
- 解决：
  - 切歌时用“全局索引 → 当前窗口的相对索引”映射；
  - 覆盖“末尾追加头块”与“窗口回收后”的两种边界；
  - 若索引不在窗口范围且无头块匹配，兜底从 DB 取该首更新 `currentSong`。

3) 窗口回收后 `playlist` 未同步导致索引漂移
- 解决：回收媒体项同时 `playlist.subList(0, n).clear()`，保证与播放器一致。

4) 记忆/恢复的曲目不正确
- 解决：全局模式下改为仅保存 `last_global_index`；恢复时调用专门的“全局恢复”入口初始化窗口并定位。

5) 自动切歌时 `AudioSink` 时间戳不连续警告
- 结论：不影响功能；保留监控。

6) 冷启动日志噪音
- 结论：多为环境/厂商与编解码能力提示；本次不做更改，但保留观察（后续若需可下调日志级别与精简首帧工作）。

---

## 验证用例与验收标准（手表优先）

- 全局顺播与循环：
  - 在“所有歌曲”点击第 184 首，顺播到末尾后自动回到真正第 1 首；
  - 靠近末尾点击/连按“下一首”均无停顿与错位。
- 元数据一致性：
  - 在 46–60 段任意曲目切歌/seek，底部标题/艺人与实际音频一致；
  - 末曲拖到尾部自动切歌，元数据即时更新，无“停留在末曲显示”。
- 记忆恢复：
  - 退出后重进：若上次处于“所有歌曲”全局模式，恢复到对应曲目与进度（暂停）。
- 歌单体验：
  - 点击歌单详情：立即进入骨架，先显本地，刷新仅在确有变更时更新；滚动期更新延后到空闲。
- 进度广播三档：
  - 设置 0.5/1.5/2.5s 三档轮换，观察进度刷新节奏明显变化；播放稳定不受影响。

通过标准：以上全部满足，无 UI 错位/跳回窗口头/记忆错误。

---

## 性能与兼容性

- 滑动窗口：每次只追加/回收 60 条左右媒体项，内存与 CPU 分布均匀；大库无“一次性大开销”。
- 回收阈值：窗口最大 240 条，保证内存上限；回收时保持当前曲目不跳（头插后 `seekTo(p+add)`）。
- 读写缓存：继续降低网络发热与功耗，不引入额外 I/O 峰值。
- UI 广播频率：2.5s 档进一步降低心跳频度，手表更省电；默认 0.5s 档保持原体验。

---

## 风险与回滚

- 如果某些设备在追加头块时仍出现极端竞态导致短时错位：
  - 回滚：禁用“头块预追加”，改为切歌瞬间检测到末尾时再切至首块（易感知但安全）；
- 若全局恢复路径异常：
  - 回滚：临时禁用 `last_global_all_songs` 读取，恢复旧的“IDs + index”路径；
- 若进度广播 2.5s 档影响体验：
  - 回滚：仅保留 0.5s/1.5s 两档。

---

## 版本与时间

- 版本：v2.5（2025-08-27—2025-08-28，修复“所有歌曲”末尾衔接与元数据一致性问题，完善记忆恢复，新增全局随机播放，修复 60→61 与末尾→首曲边界，优化歌单刷新抑制与心跳三档）。
